import prisma from './prismaService';
import { NotFoundError, BadRequestError, ForbiddenError } from '../utils/errors';

// Purchase tokens for a guide
export const initiatePayment = async (guideId: number, paymentData: any) => {
  // Validate required fields
  const { tokenAmount, paymentMethod } = paymentData;
  
  if (!tokenAmount || !paymentMethod) {
    throw new BadRequestError('Token amount and payment method are required');
  }
  
  // Check if guide exists
  const guide = await prisma.guide.findUnique({
    where: { id: guideId },
    include: {
      baseUser: {
        select: {
          firstName: true,
          lastName: true
        }
      }
    }
  });
  
  if (!guide) {
    throw new NotFoundError('Guide profile not found');
  }
  
  // Calculate payment amount based on token amount
  const tokensRequested = parseInt(tokenAmount);
  if (isNaN(tokensRequested) || tokensRequested <= 0) {
    throw new BadRequestError('Token amount must be a positive number');
  }
  
  // Token pricing (e.g., 1 token = $1)
  const tokenPrice = 1;
  const totalAmount = tokensRequested * tokenPrice;
  
  // Create payment record
  const payment = await prisma.payment.create({
    data: {
      guideId,
      amount: totalAmount,
      method: paymentMethod,
      status: 'PENDING',
      paymentType: 'TOKEN_PURCHASE',
      paymentIntentId: `pi_${Date.now()}`, // This would be generated by a real payment provider
      paymentUrl: `https://payment.example.com/tokens/${tokensRequested}`, // This would come from a real payment provider
      description: `Purchase of ${tokensRequested} tokens`
    }
  });
  
  // In a real implementation, we would now:
  // 1. Connect to a payment provider (e.g., Stripe, PayPal)
  // 2. Create a payment intent/session with them
  // 3. Update our payment record with their reference IDs
  // 4. Return payment URL or token for frontend processing
  
  return {
    payment,
    paymentUrl: `https://payment.example.com/tokens/${tokensRequested}`,
    tokensRequested
  };
};

export const getPaymentDetails = async (paymentId: number, userId: number, isTourist: boolean, isGuide: boolean) => {
  // Get the payment with details
  const payment = await prisma.payment.findUnique({
    where: { id: paymentId },
    include: {
      guide: {
        include: {
          baseUser: {
            select: {
              id: true,
              firstName: true,
              lastName: true
            }
          }
        }
      }
    }
  });
  
  if (!payment) {
    throw new NotFoundError('Payment not found');
  }
  
  // Check authorization - only guide who owns the payment can view it
  if (isGuide) {
    const guide = await prisma.guide.findFirst({
      where: { baseUserId: userId }
    });
    
    if (!guide || guide.id !== payment.guideId) {
      throw new ForbiddenError('You are not authorized to view this payment');
    }
  } else {
    throw new ForbiddenError('Unauthorized access');
  }
  
  return payment;
};

export const processPaymentCallback = async (paymentId: number, callbackData: any) => {
  // This would process a callback from a payment provider
  // In a real implementation, we would:
  // 1. Verify the authenticity of the callback (signature/webhook secret)
  // 2. Update the payment status based on the provider's response
  // 3. Add tokens to guide if payment is successful
  
  const { status, transaction_id, token_amount } = callbackData;
  
  // Find the payment
  const payment = await prisma.payment.findUnique({
    where: { id: paymentId },
    include: {
      guide: true
    }
  });
  
  if (!payment) {
    throw new NotFoundError('Payment not found');
  }
  
  // Update payment status
  const updatedPayment = await prisma.payment.update({
    where: { id: paymentId },
    data: {
      status: status || 'COMPLETED',
      // Note: transactionId doesn't exist in schema, using paymentIntentId instead
      paymentIntentId: transaction_id || payment.paymentIntentId,
      completedAt: status === 'COMPLETED' ? new Date() : null
    }
  });
  
  // If payment is completed, add tokens to guide's account
  if (status === 'COMPLETED') {
    const tokensToAdd = parseInt(token_amount);
    
    // Get current token balance
    const guide = await prisma.guide.findUnique({
      where: { id: payment.guideId },
      select: { tokenBalance: true }
    });
    
    // Add tokens to guide's account
    await prisma.guide.update({
      where: { id: payment.guideId },
      data: {
        tokenBalance: (guide?.tokenBalance || 0) + tokensToAdd
      }
    });
    
    // Create token transaction record
    await prisma.tokenTransaction.create({
      data: {
        guideId: payment.guideId,
        amount: tokensToAdd,
        type: 'PURCHASE',
        status: 'COMPLETED',
        paymentId: payment.id,
        description: `Purchased ${tokensToAdd} tokens`
      }
    });
  }
  
  return updatedPayment;
};

export const getTouristPaymentHistory = async (touristId: number) => {
  // This method is not relevant for token management
  throw new BadRequestError('Operation not supported for token management');
};

export const getGuidePaymentsReceived = async (guideId: number) => {
  // Get guide token purchase history
  const payments = await prisma.payment.findMany({
    where: { 
      guideId,
      paymentType: 'TOKEN_PURCHASE'
    },
    orderBy: {
      createdAt: 'desc'
    }
  });
  
  // Get token usage history
  const tokenTransactions = await prisma.tokenTransaction.findMany({
    where: { guideId },
    orderBy: {
      createdAt: 'desc'
    }
  });
  
  // Get current token balance
  const guide = await prisma.guide.findUnique({
    where: { id: guideId },
    select: { tokenBalance: true }
  });
  
  // Calculate statistics
  const totalPurchased = tokenTransactions
    .filter(t => t.type === 'PURCHASE' && t.status === 'COMPLETED')
    .reduce((sum, t) => sum + t.amount, 0);
    
  const totalSpent = tokenTransactions
    .filter(t => t.type === 'USAGE' && t.status === 'COMPLETED')
    .reduce((sum, t) => sum + t.amount, 0);
  
  return {
    payments,
    tokenTransactions,
    summary: {
      currentBalance: guide?.tokenBalance || 0,
      totalPurchased,
      totalSpent
    }
  };
};

export const initiateWithdrawal = async (guideId: number, withdrawalData: any) => {
  // Token system doesn't support withdrawals, but guides might request refunds
  throw new BadRequestError('Withdrawals are not supported for token management');
};

export const getWithdrawalStatus = async (withdrawalId: number, guideId: number) => {
  // Token system doesn't support withdrawals
  throw new BadRequestError('Withdrawals are not supported for token management');
};

// New methods for token management

export const useTokens = async (guideId: number, tokenData: any) => {
  // Validate required fields
  const { amount, purpose } = tokenData;
  
  if (!amount || !purpose) {
    throw new BadRequestError('Token amount and purpose are required');
  }
  
  // Check if guide exists
  const guide = await prisma.guide.findUnique({
    where: { id: guideId },
    select: { tokenBalance: true }
  });
  
  if (!guide) {
    throw new NotFoundError('Guide profile not found');
  }
  
  // Validate token amount
  const tokensToUse = parseInt(amount);
  if (isNaN(tokensToUse) || tokensToUse <= 0) {
    throw new BadRequestError('Token amount must be a positive number');
  }
  
  // Check if guide has enough tokens
  if ((guide.tokenBalance || 0) < tokensToUse) {
    throw new BadRequestError(`Insufficient token balance. Available: ${guide.tokenBalance || 0}`);
  }
  
  // Deduct tokens from guide's account
  await prisma.guide.update({
    where: { id: guideId },
    data: {
      tokenBalance: (guide.tokenBalance || 0) - tokensToUse
    }
  });
  
  // Create token transaction record
  const transaction = await prisma.tokenTransaction.create({
    data: {
      guideId,
      amount: tokensToUse,
      type: 'USAGE',
      status: 'COMPLETED',
      description: purpose
    }
  });
  
  return {
    transaction,
    newBalance: (guide.tokenBalance || 0) - tokensToUse
  };
};

export const getGuideTokenBalance = async (guideId: number) => {
  // Get guide's current token balance
  const guide = await prisma.guide.findUnique({
    where: { id: guideId },
    select: { tokenBalance: true }
  });
  
  if (!guide) {
    throw new NotFoundError('Guide profile not found');
  }
  
  return {
    tokenBalance: guide.tokenBalance || 0
  };
};

export const getTokenTransactionHistory = async (guideId: number) => {
  // Get complete token transaction history
  const transactions = await prisma.tokenTransaction.findMany({
    where: { guideId },
    orderBy: {
      createdAt: 'desc'
    }
  });
  
  return transactions;
}; 